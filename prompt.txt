./README.md
---


---
./index.html
---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Maths Breakout Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #f0f0f0;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
    }

    #game-container {
      margin: 0 auto;
      width: 1250px;
    }
  </style>
</head>

<body>
  <h1>Maths Breakout Game</h1>
  <p>Use LEFT/RIGHT to move. Type answers and hit ENTER to shoot at blocks.</p>
  <p>
    <span style="color: #2ecc71;">Green blocks</span>: easy problems (1 ball).
    <span style="color: #e74c3c;">Red blocks</span>: medium problems (3 balls).
    <span style="color: #9b59b6;">Purple blocks</span>: hard problems (spray balls).
    <span style="color: #8e44ad;">Dark purple blocks</span>: super special blocks (spray balls everywhere!)
  </p>
  <div id="game-container"></div>

  <!-- Load utility modules first -->
  <script src="js/utils/helpers.js"></script>

  <!-- Load base classes before derived classes -->
  <script src="js/math/MathProblem.js"></script>
  <script src="js/entities/blocks/Block.js"></script>

  <!-- Load derived math classes -->
  <script src="js/math/EasyMath.js"></script>
  <script src="js/math/MediumMath.js"></script>
  <script src="js/math/HardMath.js"></script>

  <!-- Load strategies -->
  <script src="js/strategies/BallReleaseStrategy.js"></script>

  <!-- Load derived entity classes -->
  <script src="js/entities/blocks/MathBlock.js"></script>
  <script src="js/entities/blocks/SpecialBlock.js"></script>
  <script src="js/entities/Paddle.js"></script>
  <script src="js/entities/Ball.js"></script>

  <!-- Load factory modules that depend on entities -->
  <script src="js/factories/BlockFactory.js"></script>

  <!-- Scene modules that depend on all other modules -->
  <script src="js/scenes/UIScene.js"></script>
  <script src="js/scenes/GameScene.js"></script>

  <!-- Main game initialization -->
  <script src="js/game.js"></script>
</body>

</html>

---
./package.json
---
{
  "name": "math-breakout-game",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "vite": "^6.2.1"
  }
}


---
./prompt.txt
---
./README.md
---


---
./index.html
---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Maths Breakout Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #f0f0f0;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
    }

    #game-container {
      margin: 0 auto;
      width: 1250px;
    }
  </style>
</head>

<body>
  <h1>Maths Breakout Game</h1>
  <p>Use LEFT/RIGHT to move. Type answers and hit ENTER to shoot at blocks.</p>
  <p>
    <span style="color: #2ecc71;">Green blocks</span>: easy problems (1 ball).
    <span style="color: #e74c3c;">Red blocks</span>: medium problems (3 balls).
    <span style="color: #9b59b6;">Purple blocks</span>: hard problems (spray balls).
    <span style="color: #8e44ad;">Dark purple blocks</span>: super special blocks (spray balls everywhere!)
  </p>
  <div id="game-container"></div>

  <!-- Load utility modules first -->
  <script src="js/utils/helpers.js"></script>

  <!-- Load base classes before derived classes -->
  <script src="js/math/MathProblem.js"></script>
  <script src="js/entities/blocks/Block.js"></script>

  <!-- Load derived math classes -->
  <script src="js/math/EasyMath.js"></script>
  <script src="js/math/MediumMath.js"></script>
  <script src="js/math/HardMath.js"></script>

  <!-- Load strategies -->
  <script src="js/strategies/BallReleaseStrategy.js"></script>

  <!-- Load derived entity classes -->
  <script src="js/entities/blocks/MathBlock.js"></script>
  <script src="js/entities/blocks/SpecialBlock.js"></script>
  <script src="js/entities/Paddle.js"></script>
  <script src="js/entities/Ball.js"></script>

  <!-- Load factory modules that depend on entities -->
  <script src="js/factories/BlockFactory.js"></script>

  <!-- Scene modules that depend on all other modules -->
  <script src="js/scenes/UIScene.js"></script>
  <script src="js/scenes/GameScene.js"></script>

  <!-- Main game initialization -->
  <script src="js/game.js"></script>
</body>

</html>

---
./package.json
---
{
  "name": "math-breakout-game",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "vite": "^6.2.1"
  }
}


---


---
./vite.config.js
---
import { defineConfig } from 'vite';

export default defineConfig({
    root: './',
    server: {
        port: 3000, // Change this if you want a different dev server port
    },
});

---
./public/vite.svg
---
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

---
./src/main.js
---
/**
 * Math Breakout Game - Main Initialization
 *
 * This file initializes the Phaser game instance and configures the game.
 */

// Game configuration
const config = {
    type: Phaser.AUTO,
    width: 1250,
    height: 600,
    parent: 'game-container',
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false
        }
    },
    scene: [GameScene, UIScene]
};

// Start game
const game = new Phaser.Game(config);

---
./src/scenes/GameScene.js
---
/**
 * Main game scene for gameplay logic
 */
class GameScene extends Phaser.Scene {
    /**
     * Default block difficulty spawn rates
     * These constants control the base probability of each difficulty level
     * and are used for initialization and resets
     */
    static DEFAULT_SPAWN_RATES = {
        EASY: 0.60,    // 60% chance for easy blocks
        MEDIUM: 0.30,  // 30% chance for medium blocks
        HARD: 0.10,    // 10% chance for hard blocks
        SUPER: 0.05    // 5% chance for super special blocks (independent of difficulty)
    };

    /**
     * Current block difficulty spawn rates
     * These values can change during gameplay to adjust difficulty
     */
    static BLOCK_SPAWN_RATES = {
        // Initialize from DEFAULT_SPAWN_RATES instead of duplicating values
        EASY: 0,    // Will be set in constructor
        MEDIUM: 0,
        HARD: 0,
        SUPER: 0
    };

    /**
     * Create a new game scene
     */
    constructor() {
        super({ key: 'GameScene', active: true });

        // Initialize BLOCK_SPAWN_RATES from DEFAULT_SPAWN_RATES
        // This avoids redundancy and ensures values are only defined once
        this.resetDifficulty();

        this.gameInProgress = true;
        this.blockGrid = [];
        this.mathBlocks = [];
    }

    /**
     * Preload game assets
     */
    preload() {
        // Generate textures on the fly
        this.generateTextures();
    }

    /**
     * Generate game textures
     */
    generateTextures() {
        // Create paddle graphic
        let g = this.add.graphics();
        g.fillStyle(0x3498db);
        g.beginPath();
        g.moveTo(0, 0);
        g.lineTo(80, 0);
        g.lineTo(64, 20);
        g.lineTo(16, 20);
        g.closePath();
        g.fillPath();
        g.generateTexture('paddle', 80, 20);
        g.clear();

        // Create ball
        g.fillStyle(0x2ecc71);
        g.fillCircle(9, 9, 9);
        g.generateTexture('ball', 18, 18);
        g.clear();

        // Create blocks - make them wider (70px instead of 60px)
        // Easy blocks - green
        g.fillStyle(0x2ecc71);
        g.fillRect(0, 0, 70, 30);
        g.generateTexture('blockEasy', 70, 30);
        g.clear();

        // Medium blocks - red
        g.fillStyle(0xe74c3c);
        g.fillRect(0, 0, 70, 30);
        g.generateTexture('blockMedium', 70, 30);
        g.clear();

        // Hard blocks - purple
        g.fillStyle(0x9b59b6);
        g.fillRect(0, 0, 70, 30);
        g.generateTexture('blockHard', 70, 30);
        g.clear();

        // Create super special block - darker purple
        g.fillStyle(0x8e44ad);
        g.fillRect(0, 0, 70, 30);

        // Add some decoration to make it look special
        // g.fillStyle(0xf1c40f); // Yellow decorations

        // // Draw decorative circles instead of stars
        // g.fillCircle(15, 15, 5);
        // g.fillCircle(35, 15, 5);
        // g.fillCircle(55, 15, 5);

        g.generateTexture('blockSuper', 70, 30);
        g.destroy();
    }

    /**
     * Create game objects
     */
    create() {
        // Reset difficulty to initial values at the start of a new game
        this.resetDifficulty();

        // Setup game groups
        this.blocks = this.physics.add.staticGroup();
        this.balls = this.physics.add.group();

        // Create paddle - center it horizontally based on game width
        const gameWidth = this.game.config.width;
        this.paddle = new Paddle(this, gameWidth / 2, 480);

        // Create blocks grid (16x5)
        this.createBlockGrid();

        // Input handling
        this.cursors = this.input.keyboard.createCursorKeys();

        // Setup collisions
        this.physics.add.collider(this.balls, this.blocks, this.handleBallBlockCollision, null, this);

        // Get reference to UI scene
        this.uiScene = this.scene.get('UIScene');
    }

    /**
     * Create the block grid
     */
    createBlockGrid() {
        const blockWidth = 70;
        const spacing = 74;
        const startX = 65;
        const startY = 50;
        const cols = 16;
        const rows = 5;

        // Clear existing blocks
        this.blockGrid = Array(cols).fill().map(() => Array(rows).fill(null));
        this.mathBlocks = [];

        // Create blocks
        for (let col = 0; col < cols; col++) {
            for (let row = 0; row < rows; row++) {
                const x = startX + col * spacing;
                const y = startY + row * 40;

                // Create a regular block
                const block = new Block(this, x, y);
                this.blockGrid[col][row] = block;
            }
        }

        // Assign math problems to the bottom row
        this.updateMathProblems();
    }

    /**
     * Update math problems on blocks
     */
    updateMathProblems() {
        if (!this.gameInProgress) return;

        // Clear all existing math blocks
        this.mathBlocks.forEach(block => {
            if (block && block.sprite && block.sprite.active) {
                block.destroy();
            }
        });
        this.mathBlocks = [];

        // Assign problems to the lowest block in each column
        for (let col = 0; col < this.blockGrid.length; col++) {
            // We no longer force specific difficulties for columns
            // All difficulty distribution is handled by the spawn rate constants
            this.assignMathProblemToColumn(col, null);
        }
    }

    /**
     * Assign a math problem to the lowest block in a specific column
     * @param {number} column - Column index
     * @param {string|null} forcedDifficulty - Optional forced difficulty
     */
    assignMathProblemToColumn(column, forcedDifficulty) {
        if (!this.gameInProgress) return;

        // Find the lowest active block in this column
        const blocksInColumn = this.blockGrid[column].filter(block =>
            block && block.sprite && block.sprite.active
        );

        // If no blocks left in this column, nothing to do
        if (blocksInColumn.length === 0) return;

        // Sort by y position (descending) to find the lowest block
        blocksInColumn.sort((a, b) => b.y - a.y);
        const lowestBlock = blocksInColumn[0];

        // Replace the regular block with a math block
        const x = lowestBlock.x;
        const y = lowestBlock.y;

        // Determine difficulty based on spawn rates or forced difficulty
        let difficulty;
        if (forcedDifficulty) {
            difficulty = forcedDifficulty;
        } else {
            // Use spawn rate constants for probability distribution
            const rand = Math.random();
            const rates = GameScene.BLOCK_SPAWN_RATES;

            if (rand < rates.EASY) {
                difficulty = 'easy';
            } else if (rand < rates.EASY + rates.MEDIUM) {
                difficulty = 'medium';
            } else {
                difficulty = 'hard';
            }
        }

        // Determine if this should be a super special block
        // Use the SUPER spawn rate constant
        let blockType = Math.random() < GameScene.BLOCK_SPAWN_RATES.SUPER ? 'super' : 'standard';

        // Destroy the regular block
        lowestBlock.destroy();

        // Create a math block using the factory
        const mathBlock = BlockFactory.createMathBlock(this, x, y, blockType, difficulty);

        // Update the grid reference
        const row = Math.floor((y - 50) / 40);
        this.blockGrid[column][row] = mathBlock;

        // Add to math blocks array for tracking
        this.mathBlocks.push(mathBlock);
    }

    /**
     * Update game state
     */
    update() {
        if (!this.gameInProgress) return;

        // Update paddle
        this.paddle.update(this.cursors);

        // Update all balls
        const gameWidth = this.game.config.width;
        const gameHeight = this.game.config.height;

        this.balls.getChildren().forEach(ballSprite => {
            if (ballSprite.active) {
                // Find the Ball instance for this sprite
                const ball = this.findBallBySprite(ballSprite);
                if (ball) {
                    ball.update(gameWidth, gameHeight);
                }
            }
        });

        // Check if we need to initialize math problems
        if (this.gameInProgress && this.blocks.countActive() > 0) {
            const hasProblems = this.mathBlocks.some(block =>
                block && block.sprite && block.sprite.active
            );

            if (!hasProblems) {
                this.updateMathProblems();

                // Potentially increase difficulty when new problems are generated
                // This creates a progressive difficulty curve as the player advances
                if (this.score && this.score.getScore) {
                    const currentScore = this.score.getScore();

                    // Increase difficulty at certain score thresholds
                    // For example, every 1000 points
                    if (currentScore > 0 && currentScore % 1000 < 100) {
                        this.increaseDifficulty();
                    }
                }
            }
        }

        // Check for victory
        if (this.blocks.countActive() === 0) {
            this.victory();
        }
    }

    /**
     * Find a Ball instance by its sprite
     * @param {Phaser.Physics.Arcade.Sprite} sprite - The sprite to find
     * @returns {Ball|null} The Ball instance or null
     */
    findBallBySprite(sprite) {
        // This is a simplified approach - in a real implementation,
        // you might want to maintain a mapping of sprites to Ball instances
        return {
            sprite: sprite,
            update: (width, height) => {
                // Handle manual wall collisions (top, left, right only)
                if (sprite.x <= 0) {
                    sprite.x = 1;
                    sprite.body.velocity.x = Math.abs(sprite.body.velocity.x);
                } else if (sprite.x >= width - sprite.width) {
                    sprite.x = width - sprite.width - 1;
                    sprite.body.velocity.x = -Math.abs(sprite.body.velocity.x);
                }

                if (sprite.y <= 0) {
                    sprite.y = 1;
                    sprite.body.velocity.y = Math.abs(sprite.body.velocity.y);
                }

                // Remove balls that fall off screen (no bounce at bottom)
                if (sprite.y > height) {
                    sprite.destroy();
                }
            },
            destroy: () => {
                if (sprite && sprite.active) {
                    sprite.destroy();
                }
            }
        };
    }

    /**
     * Handle collision between a ball and a block
     * @param {Phaser.Physics.Arcade.Sprite} ballSprite - The ball sprite
     * @param {Phaser.Physics.Arcade.Sprite} blockSprite - The block sprite
     */
    handleBallBlockCollision(ballSprite, blockSprite) {
        // Find the Block instance for this sprite
        const block = this.findBlockBySprite(blockSprite);

        if (block) {
            // Get column information before destroying the block
            const col = block.getColumn();
            const hadMathProblem = block instanceof MathBlock;

            // Handle the hit
            const points = block.onHit();

            // Update score for ball hits (not for direct answer hits)
            if (!hadMathProblem) {
                this.uiScene.updateScore(points);
            }

            // If it had a math problem, assign a new math problem to the next block in this column
            if (hadMathProblem) {
                this.assignMathProblemToColumn(col);
            }
        }
    }

    /**
     * Find a Block instance by its sprite
     * @param {Phaser.Physics.Arcade.Sprite} sprite - The sprite to find
     * @returns {Block|null} The Block instance or null
     */
    findBlockBySprite(sprite) {
        // Search through all blocks in the grid
        for (let col = 0; col < this.blockGrid.length; col++) {
            for (let row = 0; row < this.blockGrid[col].length; row++) {
                const block = this.blockGrid[col][row];
                if (block && block.sprite === sprite) {
                    return block;
                }
            }
        }

        // Also check math blocks
        for (let i = 0; i < this.mathBlocks.length; i++) {
            if (this.mathBlocks[i] && this.mathBlocks[i].sprite === sprite) {
                return this.mathBlocks[i];
            }
        }

        return null;
    }

    /**
     * Check if the answer matches any math block
     * @param {number} answer - The answer to check
     * @returns {object} Result with correct flag and points
     */
    checkAnswer(answer) {
        // Find matching problem
        let targetBlock = null;

        for (let i = 0; i < this.mathBlocks.length; i++) {
            const block = this.mathBlocks[i];
            if (block && block.sprite && block.sprite.active && block.checkAnswer(answer)) {
                targetBlock = block;
                break;
            }
        }

        if (targetBlock) {
            const points = targetBlock.problem.getPoints();

            // Use the block's ball release strategy
            targetBlock.releaseBalls();

            return { correct: true, points: points };
        } else {
            return { correct: false, points: 0 };
        }
    }

    /**
     * Shoot a ball from the paddle
     * @param {number} x - Starting X position
     * @param {number} y - Starting Y position
     * @param {number|object} targetXorDirection - Either target X coordinate or direction vector {x, y}
     * @param {number} [targetY] - Target Y coordinate (if first param is X)
     * @returns {Ball} The created ball
     */
    shootBall(x, y, targetXorDirection, targetY) {
        const ball = new Ball(this, x, y);
        ball.shoot(targetXorDirection, targetY);
        return ball;
    }

    /**
     * Handle victory
     */
    victory() {
        if (!this.gameInProgress) return;

        this.gameInProgress = false;
        this.physics.pause();

        // Tell UI scene to show victory screen
        this.uiScene.showVictory();
    }

    /**
     * Restart the game
     */
    restartGame() {
        // Clean up existing game objects
        this.cleanupGameObjects();

        // Reset difficulty to initial values
        this.resetDifficulty();

        // Reset game state
        this.gameInProgress = true;
        this.physics.resume();

        // Recreate game objects
        this.createBlockGrid();

        // Re-establish collision detection
        this.physics.add.collider(this.balls, this.blocks, this.handleBallBlockCollision, null, this);
    }

    /**
     * Clean up game objects for restart
     */
    cleanupGameObjects() {
        try {
            // Remove all collision handlers first
            this.physics.world.colliders.destroy();

            // Safely destroy all game objects
            this.balls.clear(true, true);
            this.blocks.clear(true, true);

            // Clear block grid
            for (let col = 0; col < this.blockGrid.length; col++) {
                for (let row = 0; row < this.blockGrid[col].length; row++) {
                    const block = this.blockGrid[col][row];
                    if (block) {
                        block.destroy();
                        this.blockGrid[col][row] = null;
                    }
                }
            }

            // Clear math blocks
            this.mathBlocks.forEach(block => {
                if (block) block.destroy();
            });
            this.mathBlocks = [];
        } catch (e) {
            console.error("Error cleaning up game objects:", e);
        }
    }

    /**
     * Adjust the difficulty spawn rates
     * @param {object} newRates - Object with new rates for each difficulty
     * @example
     * // Make the game harder
     * adjustDifficultyRates({ EASY: 0.4, MEDIUM: 0.4, HARD: 0.2, SUPER: 0.1 });
     */
    adjustDifficultyRates(newRates) {
        // Update only the provided rates
        if (newRates.EASY !== undefined) GameScene.BLOCK_SPAWN_RATES.EASY = newRates.EASY;
        if (newRates.MEDIUM !== undefined) GameScene.BLOCK_SPAWN_RATES.MEDIUM = newRates.MEDIUM;
        if (newRates.HARD !== undefined) GameScene.BLOCK_SPAWN_RATES.HARD = newRates.HARD;
        if (newRates.SUPER !== undefined) GameScene.BLOCK_SPAWN_RATES.SUPER = newRates.SUPER;

        // Ensure probabilities sum to 1 for difficulties (not including SUPER which is independent)
        const total = GameScene.BLOCK_SPAWN_RATES.EASY +
            GameScene.BLOCK_SPAWN_RATES.MEDIUM +
            GameScene.BLOCK_SPAWN_RATES.HARD;

        if (total !== 1) {
            // Normalize the rates
            const factor = 1 / total;
            GameScene.BLOCK_SPAWN_RATES.EASY *= factor;
            GameScene.BLOCK_SPAWN_RATES.MEDIUM *= factor;
            GameScene.BLOCK_SPAWN_RATES.HARD *= factor;

            console.log('Difficulty rates normalized to sum to 1:', GameScene.BLOCK_SPAWN_RATES);
        }
    }

    /**
     * Increase game difficulty based on score or time
     * This makes the game progressively harder as the player advances
     */
    increaseDifficulty() {
        if (!this.gameInProgress) return;

        // Get current rates
        const rates = GameScene.BLOCK_SPAWN_RATES;

        // Gradually decrease easy blocks and increase medium/hard blocks
        // This is a simple linear progression - could be made more sophisticated
        const newRates = {
            EASY: Math.max(0.3, rates.EASY - 0.05),  // Decrease easy blocks but keep at least 30%
            MEDIUM: Math.min(0.5, rates.MEDIUM + 0.03),  // Increase medium blocks up to 50%
            HARD: Math.min(0.3, rates.HARD + 0.02),  // Increase hard blocks up to 30%
            SUPER: Math.min(0.15, rates.SUPER + 0.01)  // Slightly increase super blocks up to 15%
        };

        this.adjustDifficultyRates(newRates);

        console.log('Difficulty increased:', GameScene.BLOCK_SPAWN_RATES);
    }

    /**
     * Reset difficulty to initial values
     * Call this when starting a new game
     */
    resetDifficulty() {
        // Reset to initial values from DEFAULT_SPAWN_RATES
        const defaults = GameScene.DEFAULT_SPAWN_RATES;
        GameScene.BLOCK_SPAWN_RATES.EASY = defaults.EASY;
        GameScene.BLOCK_SPAWN_RATES.MEDIUM = defaults.MEDIUM;
        GameScene.BLOCK_SPAWN_RATES.HARD = defaults.HARD;
        GameScene.BLOCK_SPAWN_RATES.SUPER = defaults.SUPER;

        console.log('Difficulty reset to initial values:', GameScene.BLOCK_SPAWN_RATES);
    }
}

---
./src/scenes/UIScene.js
---
/**
 * Scene for handling UI elements
 */
class UIScene extends Phaser.Scene {
    /**
     * Create a new UI scene
     */
    constructor() {
        super({ key: 'UIScene', active: true });
        this.score = 0;
        this.victoryElements = null;
    }

    /**
     * Create UI elements
     */
    create() {
        // Get reference to the game scene
        this.gameScene = this.scene.get('GameScene');

        // Get game dimensions
        const gameWidth = this.game.config.width;
        const gameHeight = this.game.config.height;

        // Create UI elements
        this.createAnswerInput();
        this.scoreText = this.add.text(20, gameHeight - 70, 'Score: 0', { fontSize: '24px' });
        this.messageText = this.add.text(gameWidth / 2, gameHeight - 40, '', { fontSize: '24px' }).setOrigin(0.5);

        // Setup input handling for answer submission
        this.input.keyboard.on('keydown-ENTER', () => {
            // If victory screen is showing, handle restart
            if (this.victoryElements) {
                this.restartFromVictory();
            } else {
                // Otherwise submit answer
                this.submitAnswer();
            }
        }, this);

        // Setup input handling for typing answers
        this.input.keyboard.on('keydown', e => {
            if (e.keyCode >= 48 && e.keyCode <= 57 || e.keyCode >= 96 && e.keyCode <= 105) {
                // Numbers
                this.answerText.text += e.key;
                this.updateCursorPosition();
            } else if (e.keyCode === 8) {
                // Backspace
                this.answerText.text = this.answerText.text.slice(0, -1);
                this.updateCursorPosition();
            }
        });
    }

    /**
     * Create the answer input box and cursor
     */
    createAnswerInput() {
        // Get game width for positioning
        const gameWidth = this.game.config.width;
        const gameHeight = this.game.config.height;

        // Center position for the input
        const centerX = gameWidth / 2;

        // Create answer input text
        this.answerText = this.add.text(centerX, gameHeight - 70, '', {
            fontSize: '24px',
            backgroundColor: '#fff',
            color: '#333',
            fixedWidth: 100,
            padding: { x: 10, y: 5 },
            align: 'center'
        }).setOrigin(0.5);

        // Add cursor effect and input box styling
        this.answerText.setPadding(10);
        this.answerText.setBackgroundColor('#ffffff');

        // Create input box border
        this.inputBorder = this.add.rectangle(centerX, gameHeight - 70, 120, 44, 0x3498db, 0);
        this.inputBorder.setStrokeStyle(2, 0x3498db);

        // Create blinking cursor
        this.cursor = this.add.text(
            this.answerText.x + (this.answerText.text.length * 7),
            this.answerText.y,
            '|',
            { fontSize: '24px', color: '#333' }
        ).setOrigin(0.5);

        // Blink cursor
        this.time.addEvent({
            delay: 500,
            callback: () => { this.cursor.visible = !this.cursor.visible; },
            loop: true
        });

        // Set focus indicator (light blue glow)
        this.answerText.on('pointerover', () => {
            this.inputBorder.setStrokeStyle(3, 0x3498db);
        });

        this.answerText.on('pointerout', () => {
            this.inputBorder.setStrokeStyle(2, 0x3498db);
        });

        // Make clickable
        this.answerText.setInteractive();
    }

    /**
     * Update cursor position based on text length
     */
    updateCursorPosition() {
        const textWidth = this.answerText.text.length * 12;
        this.cursor.x = this.answerText.x - (this.answerText.width / 2) + textWidth + 12;
    }

    /**
     * Submit the current answer
     */
    submitAnswer() {
        const answer = parseInt(this.answerText.text);

        // Always clear input field and update cursor on Enter
        this.answerText.text = '';
        this.updateCursorPosition();

        if (isNaN(answer)) return;

        // Tell the game scene to check the answer
        const result = this.gameScene.checkAnswer(answer);

        if (result.correct) {
            // Update score
            this.updateScore(result.points);
            this.showMessage(`Correct! +${result.points}`, '#27ae60');
        } else {
            // Penalty for wrong answer
            this.updateScore(-5);
            this.showMessage('Try again!', '#e74c3c');
        }
    }

    /**
     * Update the score
     * @param {number} points - Points to add (negative for penalty)
     */
    updateScore(points) {
        this.score = Math.max(0, this.score + points);
        this.scoreText.setText(`Score: ${this.score}`);
    }

    /**
     * Show a message to the player
     * @param {string} text - Message text
     * @param {string} color - Text color (hex)
     */
    showMessage(text, color) {
        this.messageText.setText(text).setColor(color);
        this.time.delayedCall(2000, () => {
            if (this.messageText) {
                this.messageText.setText('');
            }
        });
    }

    /**
     * Show victory screen
     */
    showVictory() {
        // Get game dimensions
        const gameWidth = this.game.config.width;
        const gameHeight = this.game.config.height;

        // Center position
        const centerX = gameWidth / 2;
        const centerY = gameHeight / 2;

        const bg = this.add.rectangle(centerX, centerY, 400, 200, 0x000000, 0.7);
        const text = this.add.text(centerX, centerY,
            `Victory!\nYour score: ${this.score}`,
            { fontSize: '32px', color: '#fff', align: 'center' }
        ).setOrigin(0.5);

        const button = this.add.text(centerX, centerY + 70, 'Play Again', {
            fontSize: '24px',
            backgroundColor: '#3498db',
            padding: { x: 20, y: 10 },
            color: '#fff'
        }).setOrigin(0.5).setInteractive();

        // Add instruction text for Enter key
        const enterText = this.add.text(centerX, centerY + 120, 'Press ENTER to restart', {
            fontSize: '16px',
            color: '#fff'
        }).setOrigin(0.5);

        // Store victory screen elements for cleanup
        this.victoryElements = [bg, text, button, enterText];

        button.on('pointerdown', () => {
            this.restartFromVictory();
        });
    }

    /**
     * Restart the game from victory screen
     */
    restartFromVictory() {
        // Only proceed if victory elements exist
        if (!this.victoryElements) return;

        this.scene.get('GameScene').restartGame();
        this.score = 0;
        this.scoreText.setText('Score: 0');

        // Clean up victory screen
        this.victoryElements.forEach(element => element.destroy());
        this.victoryElements = null;
    }

    /**
     * Get the current score
     * @returns {number} Current score
     */
    getScore() {
        return this.score;
    }
}

---
./src/strategies/BallReleaseStrategy.js
---
/**
 * Base class for ball release strategies
 */
class BallReleaseStrategy {
    /**
     * Execute the ball release strategy
     * @param {Phaser.Scene} scene - The game scene
     * @param {number} paddleX - Paddle X position
     * @param {number} paddleY - Paddle Y position
     * @param {number} targetX - Target X position
     * @param {number} targetY - Target Y position
     * @returns {Array} Array of created balls
     */
    execute(scene, paddleX, paddleY, targetX, targetY) {
        console.warn('BallReleaseStrategy.execute() called on base class - should be overridden');
        return [];
    }
}

/**
 * Strategy for releasing a single ball
 * @extends BallReleaseStrategy
 */
class StandardBallReleaseStrategy extends BallReleaseStrategy {
    /**
     * Execute the standard ball release strategy (single ball)
     * @param {Phaser.Scene} scene - The game scene
     * @param {number} paddleX - Paddle X position
     * @param {number} paddleY - Paddle Y position
     * @param {number} targetX - Target X position
     * @param {number} targetY - Target Y position
     * @returns {Array} Array of created balls
     */
    execute(scene, paddleX, paddleY, targetX, targetY) {
        // Release a single ball toward the target
        return [scene.shootBall(paddleX, paddleY - 10, targetX, targetY)];
    }
}

/**
 * Strategy for releasing multiple balls
 * @extends BallReleaseStrategy
 */
class MultiBallReleaseStrategy extends BallReleaseStrategy {
    /**
     * Execute the multi-ball release strategy (three balls)
     * @param {Phaser.Scene} scene - The game scene
     * @param {number} paddleX - Paddle X position
     * @param {number} paddleY - Paddle Y position
     * @param {number} targetX - Target X position
     * @param {number} targetY - Target Y position
     * @returns {Array} Array of created balls
     */
    execute(scene, paddleX, paddleY, targetX, targetY) {
        // Release multiple balls in different directions
        return [
            scene.shootBall(paddleX, paddleY - 10, targetX, targetY),
            scene.shootBall(paddleX, paddleY - 10, { x: 0, y: -1 }),
            scene.shootBall(paddleX, paddleY - 10, { x: -1, y: -1 })
        ];
    }
}

/**
 * Strategy for releasing balls in all directions
 * @extends BallReleaseStrategy
 */
class SuperSpecialBallReleaseStrategy extends BallReleaseStrategy {
    /**
     * Execute the super special ball release strategy (spray upwards between 10° and 170°)
     * @param {Phaser.Scene} scene - The game scene
     * @param {number} paddleX - Paddle X position
     * @param {number} paddleY - Paddle Y position
     * @param {number} targetX - Target X position
     * @param {number} targetY - Target Y position
     * @returns {Array} Array of created balls
     */
    execute(scene, paddleX, paddleY, targetX, targetY) {
        const balls = [];
        // Create balls from 10° to 170° in increments of 20°
        for (let angle = 10; angle <= 170; angle += 20) {
            const radians = Phaser.Math.DegToRad(angle + 180);
            const direction = {
                x: Math.cos(radians),
                y: Math.sin(radians)
            };
            balls.push(scene.shootBall(paddleX, paddleY - 10, direction));
        }
        return balls;
    }
}

---
./src/utils/helpers.js
---
/**
 * Utility functions for the Math Breakout Game
 */
const Helpers = {
    /**
     * Generate a random integer between min and max (inclusive)
     * @param {number} min - Minimum value
     * @param {number} max - Maximum value
     * @returns {number} Random integer
     */
    getRandomInt: function (min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    },

    /**
     * Calculate column index from x position
     * @param {number} x - X position
     * @returns {number} Column index
     */
    getBlockColumn: function (x) {
        return Math.floor((x - 65) / 74);
    },


};

---
./src/math/EasyMath.js
---
/**
 * Class for easy math problems (addition and subtraction)
 * @extends MathProblem
 */
class EasyMath extends MathProblem {
    /**
     * Create a new easy math problem
     */
    constructor() {
        super('easy');
    }

    /**
     * Generate an easy math problem (addition or subtraction)
     */
    generate() {
        if (Math.random() < 0.5) {
            // Addition
            const a = Helpers.getRandomInt(1, 10);
            const b = Helpers.getRandomInt(1, 10);
            this.expression = `${a} + ${b}`;
            this.answer = a + b;
        } else {
            // Subtraction (positive result)
            const b = Helpers.getRandomInt(1, 10);
            const a = b + Helpers.getRandomInt(0, 10);
            this.expression = `${a} - ${b}`;
            this.answer = a - b;
        }
    }
}

---
./src/math/HardMath.js
---
/**
 * Class for hard math problems (multiplication and 2-digit operations)
 * @extends MathProblem
 */
class HardMath extends MathProblem {
    /**
     * Create a new hard math problem
     */
    constructor() {
        super('hard');
    }

    /**
     * Generate a hard math problem (multiplication or 2-digit operations)
     */
    generate() {
        if (Math.random() < 0.6) {
            // Multiplication
            const a = Helpers.getRandomInt(1, 12);
            const b = Helpers.getRandomInt(1, 12);
            this.expression = `${a} × ${b}`;
            this.answer = a * b;
        } else {
            // 2-digit operations
            const isAdd = Math.random() < 0.5;
            if (isAdd) {
                const a = Helpers.getRandomInt(10, 99);
                const b = Helpers.getRandomInt(10, 99);
                this.expression = `${a} + ${b}`;
                this.answer = a + b;
            } else {
                const b = Helpers.getRandomInt(10, 99);
                const a = b + Helpers.getRandomInt(10, 99);
                this.expression = `${a} - ${b}`;
                this.answer = a - b;
            }
        }
    }
}

---
./src/math/MathProblem.js
---
/**
 * Base class for math problems
 */
class MathProblem {
    /**
     * Create a new math problem
     * @param {string} difficulty - The difficulty level ('easy' or 'hard')
     */
    constructor(difficulty = 'easy') {
        this.difficulty = difficulty;
        this.expression = '';
        this.answer = 0;
        this.generate();
    }

    /**
     * Generate a math problem
     * This method should be overridden by subclasses
     */
    generate() {
        console.warn('MathProblem.generate() called on base class - should be overridden');
    }

    /**
     * Validate if the provided answer is correct
     * @param {number} userAnswer - The user's answer to check
     * @returns {boolean} Whether the answer is correct
     */
    validate(userAnswer) {
        return userAnswer === this.answer;
    }

    /**
     * Get the point value for this problem
     * @returns {number} Points for solving this problem
     */
    getPoints() {
        switch (this.difficulty) {
            case 'hard':
                return 50;
            case 'medium':
                return 30;
            default:
                return 20;
        }
    }

    /**
     * Factory method to create a math problem of the specified difficulty
     * @param {string} difficulty - The difficulty level ('easy', 'medium', or 'hard')
     * @returns {MathProblem} A new math problem instance
     */
    static create(difficulty) {
        if (difficulty === 'hard') {
            return new HardMath();
        } else if (difficulty === 'medium') {
            return new MediumMath();
        } else {
            return new EasyMath();
        }
    }
}

---
./src/math/MediumMath.js
---
/**
 * Medium difficulty math problems
 * @extends MathProblem
 */
class MediumMath extends MathProblem {
    /**
     * Create a new medium difficulty math problem
     */
    constructor() {
        super('medium');
    }

    /**
     * Generate a medium difficulty math problem
     * Medium problems include:
     * - Two-digit addition and subtraction
     * - Simple multiplication (up to 12)
     * - Simple division with no remainder
     */
    generate() {
        const type = Helpers.getRandomInt(1, 4);

        switch (type) {
            case 1: // Two-digit addition
                const a = Helpers.getRandomInt(10, 50);
                const b = Helpers.getRandomInt(10, 50);
                this.expression = `${a} + ${b}`;
                this.answer = a + b;
                break;

            case 2: // Two-digit subtraction
                const c = Helpers.getRandomInt(30, 99);
                const d = Helpers.getRandomInt(10, 29);
                this.expression = `${c} - ${d}`;
                this.answer = c - d;
                break;

            case 3: // Simple multiplication
                const e = Helpers.getRandomInt(2, 12);
                const f = Helpers.getRandomInt(2, 12);
                this.expression = `${e} × ${f}`;
                this.answer = e * f;
                break;

            case 4: // Simple division (no remainder)
                const divisor = Helpers.getRandomInt(2, 10);
                const result = Helpers.getRandomInt(1, 10);
                const dividend = divisor * result;
                this.expression = `${dividend} / ${divisor}`;
                this.answer = result;
                break;
        }
    }
}

---
./src/factories/BlockFactory.js
---
/**
 * Factory for creating different types of blocks
 */
class BlockFactory {
    /**
     * Create a math block with specific properties
     * @param {Phaser.Scene} scene - The scene this block belongs to
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} blockType - Type of block to create ('standard', 'multi', 'super', etc.)
     * @param {string} difficulty - Math difficulty ('easy', 'medium', or 'hard')
     * @returns {MathBlock} The created block
     */
    static createMathBlock(scene, x, y, blockType, difficulty) {
        let options = {
            difficulty: difficulty
        };

        // Configure block based on type and difficulty
        if (blockType === 'super') {
            // Super special blocks always spray balls
            options.texture = 'blockSuper';
            options.ballReleaseStrategy = new SuperSpecialBallReleaseStrategy();
        } else {
            // For standard blocks, assign strategy based on difficulty
            if (difficulty === 'hard') {
                // Hard blocks (purple) spray balls
                options.texture = 'blockHard'; // Ensure texture is set
                options.ballReleaseStrategy = new SuperSpecialBallReleaseStrategy();
            } else if (difficulty === 'medium') {
                // Medium blocks (red) shoot 3 balls
                options.texture = 'blockMedium'; // Ensure texture is set
                options.ballReleaseStrategy = new MultiBallReleaseStrategy();
            } else {
                // Easy blocks (green) shoot 1 ball
                options.texture = 'blockEasy'; // Ensure texture is set
                options.ballReleaseStrategy = new StandardBallReleaseStrategy();
            }
        }

        return new MathBlock(scene, x, y, options);
    }
}

---
./src/entities/Ball.js
---
/**
 * Ball class for projectiles
 */
class Ball {
    /**
     * Create a new ball
     * @param {Phaser.Scene} scene - The scene this ball belongs to
     * @param {number} x - Initial X position
     * @param {number} y - Initial Y position
     */
    constructor(scene, x, y) {
        this.scene = scene;
        this.sprite = scene.balls.create(x, y, 'ball');
        this.sprite.setCollideWorldBounds(false);
        this.sprite.setBounce(1);
        this.speed = 300;
    }

    /**
     * Shoot the ball in a specific direction
     * @param {number|object} targetXorDirection - Either target X coordinate or direction vector {x, y}
     * @param {number} [targetY] - Target Y coordinate (if first param is X)
     */
    shoot(targetXorDirection, targetY) {
        if (typeof targetXorDirection === 'number' && typeof targetY === 'number') {
            // Shoot toward specific coordinates
            const angle = Phaser.Math.Angle.Between(
                this.sprite.x,
                this.sprite.y,
                targetXorDirection,
                targetY
            );
            this.scene.physics.velocityFromRotation(angle, this.speed, this.sprite.body.velocity);
        } else {
            // Use provided direction vector
            const direction = targetXorDirection;
            const norm = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
            this.sprite.setVelocity(
                direction.x / norm * this.speed,
                direction.y / norm * this.speed
            );
        }
    }

    /**
     * Update ball position and handle boundary collisions
     * @param {number} width - Game width
     * @param {number} height - Game height
     */
    update(width, height) {
        if (!this.sprite.active) return;

        // Handle manual wall collisions (top, left, right only)
        if (this.sprite.x <= 0) {
            this.sprite.x = 1;
            this.sprite.body.velocity.x = Math.abs(this.sprite.body.velocity.x);
        } else if (this.sprite.x >= width - this.sprite.width) {
            this.sprite.x = width - this.sprite.width - 1;
            this.sprite.body.velocity.x = -Math.abs(this.sprite.body.velocity.x);
        }

        if (this.sprite.y <= 0) {
            this.sprite.y = 1;
            this.sprite.body.velocity.y = Math.abs(this.sprite.body.velocity.y);
        }

        // Remove balls that fall off screen (no bounce at bottom)
        if (this.sprite.y > height) {
            this.destroy();
        }
    }

    /**
     * Destroy this ball
     */
    destroy() {
        if (this.sprite && this.sprite.active) {
            this.sprite.destroy();
        }
    }
}

---
./src/entities/Paddle.js
---
/**
 * Paddle (player-controlled) class
 */
class Paddle {
    /**
     * Create a new paddle
     * @param {Phaser.Scene} scene - The scene this paddle belongs to
     * @param {number} x - Initial X position
     * @param {number} y - Initial Y position
     */
    constructor(scene, x, y) {
        this.scene = scene;
        this.sprite = scene.physics.add.image(x, y, 'paddle').setImmovable(true);
        this.speed = 7;

        // Get the game width from the scene's game config
        const gameWidth = scene.game.config.width;

        // Calculate paddle bounds based on game width and paddle width
        // The paddle width is 80px based on the texture generation in GameScene.js
        const paddleHalfWidth = 40; // Half of the paddle width

        // Set minimum X to be the paddle's half-width from the left edge
        this.minX = paddleHalfWidth;

        // Set maximum X to be the paddle's half-width from the right edge
        this.maxX = gameWidth - paddleHalfWidth;
    }

    /**
     * Update paddle position based on input
     * @param {Phaser.Input.Keyboard.CursorKeys} cursors - Cursor keys for input
     */
    update(cursors) {
        if (cursors.left.isDown) {
            this.moveLeft();
        } else if (cursors.right.isDown) {
            this.moveRight();
        }

        // Keep paddle in bounds
        this.sprite.x = Phaser.Math.Clamp(this.sprite.x, this.minX, this.maxX);
    }

    /**
     * Move paddle left
     */
    moveLeft() {
        this.sprite.x -= this.speed;
    }

    /**
     * Move paddle right
     */
    moveRight() {
        this.sprite.x += this.speed;
    }

    /**
     * Get current X position
     * @returns {number} Current X position
     */
    getX() {
        return this.sprite.x;
    }

    /**
     * Get current Y position
     * @returns {number} Current Y position
     */
    getY() {
        return this.sprite.y;
    }
}

---
./src/entities/blocks/Block.js
---
/**
 * Base class for all block types
 */
class Block {
    /**
     * Create a new block
     * @param {Phaser.Scene} scene - The scene this block belongs to
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {string} texture - Texture key to use
     */
    constructor(scene, x, y, texture = 'blockEasy') {
        this.scene = scene;
        this.x = x;
        this.y = y;
        this.texture = texture;
        this.sprite = null;
        this.create();
    }

    /**
     * Create the block sprite
     */
    create() {
        this.sprite = this.scene.blocks.create(this.x, this.y, this.texture);
        return this.sprite;
    }

    /**
     * Handle collision with a ball
     * @param {Ball} ball - The ball that hit this block
     */
    onHit(ball) {
        this.destroy();
        return 10; // Base score for destroying a block
    }

    /**
     * Destroy this block
     */
    destroy() {
        if (this.sprite && this.sprite.active) {
            this.sprite.destroy();
        }
    }

    /**
     * Get the column index of this block
     * @returns {number} Column index
     */
    getColumn() {
        return Helpers.getBlockColumn(this.x);
    }
}

---
./src/entities/blocks/MathBlock.js
---
/**
 * Block with a math problem
 * @extends Block
 */
class MathBlock extends Block {
    /**
     * Create a new math block
     * @param {Phaser.Scene} scene - The scene this block belongs to
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {object|string} options - Options object or difficulty string
     */
    constructor(scene, x, y, options = {}) {
        // Handle case where options is just a difficulty string (for backward compatibility)
        if (typeof options === 'string') {
            options = { difficulty: options };
        }

        // Default options
        const defaults = {
            difficulty: 'easy',
            texture: null,
            ballReleaseStrategy: new StandardBallReleaseStrategy(),
            specialEffect: null,
            scoreMultiplier: 1
        };

        // Merge provided options with defaults
        const config = { ...defaults, ...options };

        // Determine texture based on difficulty if not specified
        let texture = config.texture;
        if (!texture) {
            if (config.difficulty === 'hard') {
                texture = 'blockHard';
            } else if (config.difficulty === 'medium') {
                texture = 'blockMedium';
            } else {
                texture = 'blockEasy';
            }
        }

        super(scene, x, y, texture);

        this.problem = null;
        this.text = null;
        this.difficulty = config.difficulty;

        // Store strategies and behaviors
        this.ballReleaseStrategy = config.ballReleaseStrategy;
        this.specialEffect = config.specialEffect;
        this.scoreMultiplier = config.scoreMultiplier;

        // Set math problem based on difficulty
        this.setMathProblem(config.difficulty);
    }

    /**
     * Set a math problem for this block
     * @param {string} difficulty - Difficulty level
     */
    setMathProblem(difficulty) {
        this.problem = MathProblem.create(difficulty);

        // Create text display for the problem
        if (this.text) {
            this.text.destroy();
        }

        this.text = this.scene.add.text(this.x, this.y, this.problem.expression, {
            fontSize: '16px',
            color: '#fff',
            fontStyle: 'bold'
        }).setOrigin(0.5).setData('blockRef', this.sprite);

        // Store problem in the sprite for collision handling
        this.sprite.setData('problem', this.problem);
    }

    /**
     * Check if the answer matches this block's problem
     * @param {number} answer - The answer to check
     * @returns {boolean} Whether the answer is correct
     */
    checkAnswer(answer) {
        return this.problem && this.problem.validate(answer);
    }

    /**
     * Release balls according to the block's strategy
     * @returns {Array} Array of created balls
     */
    releaseBalls() {
        const paddleX = this.scene.paddle.getX();
        const paddleY = this.scene.paddle.getY();
        return this.ballReleaseStrategy.execute(this.scene, paddleX, paddleY, this.x, this.y);
    }

    /**
     * Apply special effect when block is hit
     * @param {Ball} ball - The ball that hit this block
     */
    applySpecialEffect(ball) {
        if (this.specialEffect) {
            this.specialEffect(this.scene, ball, this);
        }
    }

    /**
     * Get the column index of this block
     * @returns {number} Column index
     */
    getColumn() {
        return Helpers.getBlockColumn(this.x);
    }

    /**
     * Handle collision with a ball
     * @param {Ball} ball - The ball that hit this block
     * @returns {number} Score for destroying this block
     */
    onHit(ball) {
        // Apply any special effects
        this.applySpecialEffect(ball);

        // Clean up text when block is destroyed
        if (this.text) {
            this.text.destroy();
        }

        super.destroy();

        // Return score based on difficulty and multiplier
        return this.problem ?
            this.problem.getPoints() * this.scoreMultiplier :
            10 * this.scoreMultiplier;
    }

    /**
     * Destroy this block
     */
    destroy() {
        if (this.text) {
            this.text.destroy();
        }
        super.destroy();
    }
}

---
